label1	int curl_mvsprintf ( char * buffer , const char * format , va_list ap_save ) { int retcode ; retcode = dprintf_formatf ( & buffer , storebuffer , format , ap_save ) ; * buffer = 0 ; return retcode ; }
label2	static int alloc_addbyter ( int output , FILE * data ) {struct asprintf * infop = ( struct asprintf * ) data ; unsigned char outc = ( unsigned char ) output ; if ( ! infop -> buffer ) { infop -> buffer = malloc ( 32 ) ; if ( ! infop -> buffer ) { infop -> fail = 1 ; return - 1 ; } infop -> alloc = 32 ; infop -> len = 0 ; } else if ( infop -> len + 1 >= infop -> alloc ) { char * newptr ; newptr = realloc ( infop -> buffer , infop -> alloc * 2 ) ; if ( ! newptr ) { infop -> fail = 1 ; return - 1 ; } infop -> buffer = newptr ; infop -> alloc *= 2 ; } infop -> buffer [ infop -> len ] = outc ; infop -> len ++ ; return outc ;}
label1	char * curl_mvaprintf ( const char * format , va_list ap_save ) { int retcode ; struct asprintf info ; info . buffer = NULL ; info . len = 0 ; info . alloc = 0 ; info . fail = 0 ; retcode = dprintf_formatf ( & info , alloc_addbyter , format , ap_save ) ; if ( ( - 1 == retcode ) || info . fail ) { if ( info . alloc ) free ( info . buffer ) ; return NULL ; } if ( info . alloc ) { info . buffer [ info . len ] = 0 ; return info . buffer ; } else return strdup ( "" ) ; }
label2	static int jbig2_word_stream_buf_get_next_word ( Jbig2WordStream * self , int offset , uint32_t * word ) { Jbig2WordStreamBuf * z = ( Jbig2WordStreamBuf * ) self ; const byte * data = z -> data ; uint32_t result ; if ( offset + 4 < z -> size ) result = ( data [ offset ] << 24 ) | ( data [ offset + 1 ] << 16 ) | ( data [ offset + 2 ] << 8 ) | data [ offset + 3 ] ; else if ( offset > z -> size ) return - 1 ; else { int i ; result = 0 ; for ( i = 0 ; i < z -> size - offset ; i ++ ) result |= data [ offset + i ] << ( ( 3 - i ) << 3 ) ; } * word = result ; return 0 ; }
label1	int curl_mprintf ( const char * format , ... ) {int retcode ; va_list ap_save ; va_start ( ap_save , format ) ; retcode = dprintf_formatf ( stdout , fputc , format , ap_save ) ; va_end ( ap_save ) ; return retcode ; }
label2	int jbig2_text_region ( Jbig2Ctx * ctx , Jbig2Segment * segment , const byte * segment_data ) { int offset = 0 ; Jbig2RegionSegmentInfo region_info ; Jbig2TextRegionParams params ; Jbig2Image * image = NULL ; Jbig2SymbolDict * * dicts = NULL ; int n_dicts = 0 ; uint16_t flags = 0 ; uint16_t huffman_flags = 0 ; Jbig2ArithCx * GR_stats = NULL ; int code = 0 ; Jbig2WordStream * ws = NULL ; Jbig2ArithState * as = NULL ; int table_index = 0 ; const Jbig2HuffmanParams * huffman_params = NULL ; if ( segment -> data_length < 17 ) goto too_short ; jbig2_get_region_segment_info ( & region_info , segment_data ) ; offset += 17 ; flags = jbig2_get_uint16 ( segment_data + offset ) ; offset += 2 ; jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , segment -> number , "text region header flags 0x%04x" , flags ) ; memset ( & params , 0 , sizeof ( Jbig2TextRegionParams ) ) ; params . SBHUFF = flags & 0x0001 ; params . SBREFINE = flags & 0x0002 ; params . LOGSBSTRIPS = ( flags & 0x000c ) >> 2 ; params . SBSTRIPS = 1 << params . LOGBSTRIPS ; params . REFCORNER = ( Jbig2RefCorner ) ( ( flags & 0x0030 ) >> 4 ) ; params . TRANSPOSED = flags & 0x0040 ; params . SBCOMBOP = ( Jbig2ComposeOp ) ( ( flags & 0x0180 ) >> 7 ) ; params . SBDEFPIXEL = flags & 0x0200 ; params . SBDSOFFSET = ( flags & 0x7C00 ) >> 10 ; if ( params . SBDSOFFSET > 0x0f ) params . SBDSOFFSET -= 0x20 ; params . SBRTEMPLATE = flags & 0x8000 ; if ( params . SBDSOFFSET ) { jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , segment -> number , "text region has SBDSOFFSET %d" , params . SBDSOFFSET ) ; } if ( params . SBHUFF ) { huffman_flags = jbig2_get_uint16 ( segment_data + offset ) ; offset += 2 ; if ( huffman_flags & 0x8000 ) jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , segment -> number , "reserved bit 15 of text region huffman flags is not zero" ) ; } else { if ( ( params . SBREFINE ) && ! ( params . SBRTEMPLATE ) ) { params . sbrat [ 0 ] = segment_data [ offset ] ; params . sbrat [ 1 ] = segment_data [ offset + 1 ] ; params . sbrat [ 2 ] = segment_data [ offset + 2 ] ; params . brat [ 3 ] = segment_data [ offset + 3 ] ; offset += 4 ; } } params . SBNUMINSTANCES = jbig2_get_uint32 ( segment_data + offset ) ; offset += 4 ; if ( params . SBHUFF ) { switch ( huffman_flags & 0x0003 ) { case 0 : params . SBHUFFFS = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_F ) ; break ; case 1 : params . SBHUFFFS = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_G ) ; break ; case 3 : huffman_params = jbig2_find_table ( ctx , segment , table_index ) ; if ( huffman_params == NULL ) { code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "Custom FS huffman table not found (%d)" , table_index ) ; goto cleanup1 ; } params . SBHUFFFS = jbig2_build_huffman_table ( ctx , huffman_params ) ; ++ table_index ; break ; case 2 : default : code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "text region specified invalid FS huffman table" ) ; goto cleanup1 ; break ; } if ( params . SBHUFFFS == NULL ) { code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> umber , "failed to allocate text region specified FS huffman table" ) ; goto cleanup1 ; } switch ( ( huffman_flags & 0x000c ) >> 2 ) { case 0 : params . SBHUFFDS = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_H ) ; break ; case 1 : params . SBHUFFDS = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_I ) ; break ; case 2 : params . SBHUFFDS = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_J ) ; break ; case 3 : huffman_params = jbig2_find_table ( ctx , segment , table_index ) ; if ( huffman_params == NULL ) { code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "Custom DS huffman table not found (%d)" , table_index ) ; goto cleanup1 ; } params . SBHUFFDS = jbig2_build_huffman_table ( ctx , huffman_params ) ; ++ table_index ; break ; } if ( params . SBHUFFDS == NULL ) { code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "failed to allocate text region specified DS huffman table" ) ; goto cleanup1 ; } switch ( ( huffman_flags & 0x0030 ) >> 4 ) { cse 0 : params . SBHUFFDT = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_K ) ; break ; case 1 : params . SBHUFFDT = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_L ) ; break ; case 2 : params . SBHUFFDT = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_M ) ; break ; case 3 : huffman_params = jbig2_find_table ( ctx , segment , table_index ) ; if ( huffman_params == NULL ) { code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "Custom DT huffman table not found (%d)" , table_index ) ; goto cleanup1 ; } params . SBHUFFDT = jbig2_build_huffman_table ( ctx , huffman_params ) ; ++ table_index ; break ; } if ( params . SBHUFFDT == NULL ) { code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "failed to allocate text region specified DT huffman table" ) ; goto cleanup1 ; } switch ( ( huffman_flags & 0x00c0 ) >> 6 ) { case 0 : params . SBHUFFRDW = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_N ) ; break ; case 1 : params . SBHUFFRDW = jbig2_bild_huffman_table ( ctx , & jbig2_huffman_params_O ) ; break ; case 3 : huffman_params = jbig2_find_table ( ctx , segment , table_index ) ; if ( huffman_params == NULL ) { code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "Custom RDW huffman table not found (%d)" , table_index ) ; goto cleanup1 ; } params . SBHUFFRDW = jbig2_build_huffman_table ( ctx , huffman_params ) ; ++ table_index ; break ; case 2 : default : code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "text region specified invalid RDW huffman table" ) ; goto cleanup1 ; break ; } if ( params . SBHUFFRDW == NULL ) { code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "failed to allocate text region specified RDW huffman table" ) ; goto cleanup1 ; } switch ( ( huffman_flags & 0x0300 ) >> 8 ) { case 0 : params . SBHUFFRDH = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_N ) ; break ; case 1 : params . SBHUFFRDH = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_O ) ; break ; ase 3 : huffman_params = jbig2_find_table ( ctx , segment , table_index ) ; if ( huffman_params == NULL ) { code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "Custom RDH huffman table not found (%d)" , table_index ) ; goto cleanup1 ; } params . SBHUFFRDH = jbig2_build_huffman_table ( ctx , huffman_params ) ; ++ table_index ; break ; case 2 : default : code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "text region specified invalid RDH huffman table" ) ; goto cleanup1 ; break ; } if ( params . SBHUFFRDH == NULL ) { code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "failed to allocate text region specified RDH huffman table" ) ; goto cleanup1 ; } switch ( ( huffman_flags & 0x0c00 ) >> 10 ) { case 0 : params . SBHUFFRDX = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_N ) ; break ; case 1 : params . SBHUFFRDX = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_O ) ; break ; case 3 : huffman_params = jbig2_find_table ( ctx , segment , tale_index ) ; if ( huffman_params == NULL ) { code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "Custom RDX huffman table not found (%d)" , table_index ) ; goto cleanup1 ; } params . SBHUFFRDX = jbig2_build_huffman_table ( ctx , huffman_params ) ; ++ table_index ; break ; case 2 : default : code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "text region specified invalid RDX huffman table" ) ; goto cleanup1 ; break ; } if ( params . SBHUFFRDX == NULL ) { code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "failed to allocate text region specified RDX huffman table" ) ; goto cleanup1 ; } switch ( ( huffman_flags & 0x3000 ) >> 12 ) { case 0 : params . SBHUFFRDY = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_N ) ; break ; case 1 : params . SBHUFFRDY = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_O ) ; break ; case 3 : huffman_params = jbig2_find_table ( ctx , segment , table_index ) ; if ( huffman_params == NULL ) { code = jbig2_erro  ctx , JBIG2_SEVERITY_FATAL , segment -> number , "Custom RDY huffman table not found (%d)" , table_index ) ; goto cleanup1 ; } params . SBHUFFRDY = jbig2_build_huffman_table ( ctx , huffman_params ) ; ++ table_index ; break ; case 2 : default : code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "text region specified invalid RDY huffman table" ) ; goto cleanup1 ; break ; } if ( params . SBHUFFRDY == NULL ) { code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "failed to allocate text region specified RDY huffman table" ) ; goto cleanup1 ; } switch ( ( huffman_flags & 0x4000 ) >> 14 ) { case 0 : params . SBHUFFRSIZE = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_A ) ; break ; case 1 : huffman_params = jbig2_find_table ( ctx , segment , table_index ) ; if ( huffman_params == NULL ) { code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "Custom RSIZE huffman table not found (%d)" , table_index ) ; goto cleanup1 ; } params . SBHUFFRSIZE = jbig2_buld_huffman_table ( ctx , huffman_params ) ; ++ table_index ; break ; } if ( params . SBHUFFRSIZE == NULL ) { code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "failed to allocate text region specified RSIZE huffman table" ) ; goto cleanup1 ; } if ( huffman_flags & 0x8000 ) { jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , segment -> number , "text region huffman flags bit 15 is set, contrary to spec" ) ; } } jbig2_error ( ctx , JBIG2_SEVERITY_INFO , segment -> number , "text region: %d x %d @ (%d,%d) %d symbols" , region_info . width , region_info . height , region_info . x , region_info . y , params . SBNUMINSTANCES ) ; n_dicts = jbig2_sd_count_referred ( ctx , segment ) ; if ( n_dicts != 0 ) { dicts = jbig2_sd_list_referred ( ctx , segment ) ; } else { code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "text region refers to no symbol dictionaries!" ) ; goto cleanup1 ; } if ( dicts == NULL ) { code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "unable t etrive symbol dictionaries! previous parsing error?" ) ; goto cleanup1 ; } else { int index ; if ( dicts [ 0 ] == NULL ) { code = jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , segment -> number , "unable to find first referenced symbol dictionary!" ) ; goto cleanup1 ; } for ( index = 1 ; index < n_dicts ; index ++ ) if ( dicts [ index ] == NULL ) { jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , segment -> number , "unable to find all referenced symbol dictionaries!" ) ; n_dicts = index ; } } { int stats_size = params . SBRTEMPLATE ? 1 << 10 : 1 << 13 ; GR_stats = jbig2_new ( ctx , Jbig2ArithCx , stats_size ) ; if ( GR_stats == NULL ) { code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "could not allocate GR_stats" ) ; goto cleanup1 ; } memset ( GR_stats , 0 , stats_size ) ; } image = jbig2_image_new ( ctx , region_info . width , region_info . height ) ; if ( image == NULL ) { code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "couldn't allocate text region image" ) ; goto ceanup2 ; } ws = jbig2_word_stream_buf_new ( ctx , segment_data + offset , segment -> data_length - offset ) ; if ( ws == NULL ) { code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "couldn't allocate ws in text region image" ) ; goto cleanup2 ; } as = jbig2_arith_new ( ctx , ws ) ; if ( as == NULL ) { code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "couldn't allocate as in text region image" ) ; goto cleanup2 ; } if ( ! params . SBHUFF ) { int SBSYMCODELEN , index ; int SBNUMSYMS = 0 ; for ( index = 0 ; index < n_dicts ; index ++ ) { SBNUMSYMS += dicts [ index ] -> n_symbols ; } params . IADT = jbig2_arith_int_ctx_new ( ctx ) ; params . IAFS = jbig2_arith_int_ctx_new ( ctx ) ; params . IADS = jbig2_arith_int_ctx_new ( ctx ) ; params . IAIT = jbig2_arith_int_ctx_new ( ctx ) ; if ( ( params . IADT == NULL ) || ( params . IAFS == NULL ) || ( params . IADS == NULL ) || ( params . IAIT == NULL ) ) { code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "couln't allocate text region image data" ) ; goto cleanup3 ; } for ( SBSYMCODELEN = 0 ; ( 1 << SBSYMCODELEN ) < SBNUMSYMS ; SBSYMCODELEN ++ ) { } params . IAID = jbig2_arith_iaid_ctx_new ( ctx , SBSYMCODELEN ) ; params . IARI = jbig2_arith_int_ctx_new ( ctx ) ; params . IARDW = jbig2_arith_int_ctx_new ( ctx ) ; params . IARDH = jbig2_arith_int_ctx_new ( ctx ) ; params . IARDX = jbig2_arith_int_ctx_new ( ctx ) ; params . IARDY = jbig2_arith_int_ctx_new ( ctx ) ; if ( ( params . IAID == NULL ) || ( params . IARI == NULL ) || ( params . IARDW == NULL ) || ( params . IARDH == NULL ) || ( params . IARDX == NULL ) || ( params . IARDY == NULL ) ) { code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "couldn't allocate text region image data" ) ; goto cleanup4 ; } } code = jbig2_decode_text_region ( ctx , segment , & params , ( const Jbig2SymbolDict * const * ) dicts , n_dicts , image , segment_data + offset , segment -> data_length - offset , GR_stats , as , ws ) ; if ( code < 0 ) { jbig2_error ( ctx , BIG2_SEVERITY_FATAL , segment -> number , "failed to decode text region image data" ) ; goto cleanup4 ; } if ( ( segment -> flags & 63 ) == 4 ) { segment -> result = jbig2_image_clone ( ctx , image ) ; } else { jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , segment -> number , "composing %dx%d decoded text region onto page at (%d, %d)" , region_info . width , region_info . height , region_info . x , region_info . y ) ; jbig2_page_add_result ( ctx , & ctx -> pages [ ctx -> current_page ] , image , region_info . x , region_info . y , region_info . op ) ; } cleanup4 : if ( ! params . SBHUFF ) { jbig2_arith_iaid_ctx_free ( ctx , params . IAID ) ; jbig2_arith_int_ctx_free ( ctx , params . IARI ) ; jbig2_arith_int_ctx_free ( ctx , params . IARDW ) ; jbig2_arith_int_ctx_free ( ctx , params . IARDH ) ; jbig2_arith_int_ctx_free ( ctx , params . IARDX ) ; jbig2_arith_int_ctx_free ( ctx , params . IARDY ) ; } cleanup3 : if ( ! params . SBHUFF ) { jbig2_arith_int_ctx_free ( ctx , params . IADT ) ; jbig2_arith_int_ctx_free ( tx , params . IAFS ) ; jbig2_arith_int_ctx_free ( ctx , params . IADS ) ; jbig2_arith_int_ctx_free ( ctx , params . IAIT ) ; } jbig2_free ( ctx -> allocator , as ) ; jbig2_word_stream_buf_free ( ctx , ws ) ; cleanup2 : jbig2_free ( ctx -> allocator , GR_stats ) ; jbig2_image_release ( ctx , image ) ; cleanup1 : if ( params . SBHUFF ) { jbig2_release_huffman_table ( ctx , params . SBHUFFFS ) ; jbig2_release_huffman_table ( ctx , params . SBHUFFDS ) ; jbig2_release_huffman_table ( ctx , params . SBHUFFDT ) ; jbig2_release_huffman_table ( ctx , params . SBHUFFRDX ) ; jbig2_release_huffman_table ( ctx , params . SBHUFFRDY ) ; jbig2_release_huffman_table ( ctx , params . SBHUFFRDW ) ; jbig2_release_huffman_table ( ctx , params . SBHUFFRDH ) ; jbig2_release_huffman_table ( ctx , params . SBHUFFRSIZE ) ; } jbig2_free ( ctx -> allocator , dicts ) ; return code ; too_short : return jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "Segment too short" ) ; }